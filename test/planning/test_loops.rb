$LOAD_PATH.unshift File.expand_path(File.join('..', '..', 'lib'), File.dirname(__FILE__))
require 'roby/test/common'
require 'roby/planning'

require 'flexmock'
require 'roby/tasks/simple'

class TC_PlanningLoop < Test::Unit::TestCase
    include Roby::Planning
    include Roby::SelfTest
    include Roby::SelfTest::Assertions

    # The planner model
    attr_reader :planner_model
    # The task model
    attr_reader :task_model
    # The options to be used for the planning tasks generated by the loop
    # planner
    attr_reader :planning_task_options

    def setup
        super
	Roby.app.filter_backtraces = false

	task_model = @task_model = Tasks::Simple.new_submodel
        pattern_id = 0
	@planner_model = Class.new(Planning::Planner) do
	    method(:task) do
                pattern_id += 1
		task_model.new(:id => pattern_id)
	    end
	end

	@planning_task_options = {
	    :planning_owners => nil,
	    :planner_model => planner_model, 
	    :planned_model => Tasks::Simple, 
	    :planning_method => "task", 
	    :method_name => 'task', 
	    :method_options => {} }
    end

    def teardown
        @planner_model, @task_model, @planning_task_options = nil
        super
    end

    # Prepare the default plan for all planning loop tests
    def prepare_plan(loop_options = {})
	plan.add_mission(main_task = Roby::Task.new)
	loop_task_options = planning_task_options.merge(loop_options)
	loop_planner = PlanningLoop.new(loop_task_options)
	main_task.planned_by loop_planner

        return main_task, loop_planner
    end

    def wait_for_planning_end(planning_task)
        planning_task.thread.join
        process_events
    end

    # Waits for +planning_task+ to finish and returns the planned result
    def planning_task_result(planning_task)
        assert(planning_task)
        assert(planning_task.running? || planning_task.success?, "#{planning_task} is neither running nor stopped")
        if planning_task.running?
            planning_task.thread.join
            process_events
        end
	assert(planning_task.success?, "#{planning_task} was supposed to finished successfully, but finished with #{planning_task.terminal_event.context}")
	planning_task.planned_task
    end

    def test_append_pattern
        main_task, loop_planner = prepare_plan

	loop_planner.append_pattern
	assert_equal(1, main_task.children.to_a.size)
	first_task = main_task.children.find { true }
	assert_equal(Tasks::Simple, first_task.class)
	first_planner = first_task.planning_task
	assert_equal(0, first_planner.arguments[:method_options][:pattern_id])
	assert_equal(planning_task_options.merge(:method_options => { :pattern_id => 0 }), 
		     first_planner.arguments)
	assert_equal(1, loop_planner.patterns.size)

	loop_planner.append_pattern
	assert_equal(2, main_task.children.to_a.size)
	second_task = main_task.children.find { |t| t != first_task }
	assert_equal(Tasks::Simple, second_task.class)
	second_planner = second_task.planning_task
	assert_equal(planning_task_options.merge(:method_options => { :pattern_id => 1 }), 
		     second_planner.arguments)
	assert_equal(2, loop_planner.patterns.size)
    end

    # First use-case: non periodic loops with non-zero lookahead. It means that
    # a generated subplan will only be started if #loop_start! is called on the
    # loop planner, and that the system tries to always have some prepared
    # subplans ready to be executed.
    def test_nonperiodic
        main_task, loop_planner = prepare_plan :period => nil, :lookahead => 2
	loop_planner.start!

        # We have a lookahead of 2, so we should have two patterns. The first
        # planner should be already running but the second one should wait for
        # the first to finish
        assert_equal(2, loop_planner.patterns.size)
        first_planner = loop_planner.patterns[-1].first
        second_planner = loop_planner.patterns[-2].first
        assert(first_planner.running?)
        assert(!second_planner.running?)
	
        # Wait for the first two patterns to be planned and check the result.
        # The planned tasks should not be started until we call loop_start!
        # explicitely
	first_task = planning_task_result(first_planner)
	assert(second_planner.running?)
	assert_equal(1, first_task.arguments[:id])
	assert(!first_task.running?)
	assert_equal(2, loop_planner.patterns.size)

	second_task = planning_task_result(second_planner)
	assert_equal(2, second_task.arguments[:id])
	assert(!first_task.running?)
        assert(!second_task.running?)
	assert_equal(2, loop_planner.patterns.size)

        # Start the first pattern, check we have one more planner and that it
        # is running to keep the lookahead
	loop_planner.loop_start!
	assert(first_task.running?)
        assert(!second_task.running?)
	assert_equal(3, main_task.children.to_a.size)
        third_planner = loop_planner.last_planning_task
        assert(! [first_planner, second_planner].include?(third_planner))
        assert(third_planner.running?)

        # Stop the first task. We have no period here, so the second task
        # should not be running until we call #loop_start! again
	first_task.success!
	assert(!second_task.running?)
	loop_planner.loop_start!
	assert(second_task.running?)

        # We started the second pattern, so a fourth should be in preparation
        # since we did not call #process_events in the meantime, so the third
        # planner is still running from Roby's point of view
        fourth_planner = loop_planner.last_planning_task
        assert(! [first_planner, second_planner, third_planner].include?(fourth_planner))
        assert(third_planner.running?)
        assert(!fourth_planner.running?)

        # Now, we make the second task finish and call #loop_start! before
        # actually acknowledging the end of the third planner. The loop should
        # nicely handle that by starting the third task and the fourth planner
        # right after the end of planning.
	second_task.success!
	loop_planner.loop_start!
        assert(third_planner.running?)
        third_task = planning_task_result(third_planner)
	assert(third_task.running?)
	assert(fourth_planner.running?)
    end

    # Second use-case: periodic loops with non-zero lookahead. It means that a
    # generated subplan will be started either because #loop_start! is called
    # *or* because a specified timespan has been reached since the last pattern
    # end. The system tries to always have some prepared subplans ready to be
    # executed.
    def test_periodic
        main_task, loop_planner = prepare_plan :period => 1, :lookahead => 2
	loop_planner.start!

	FlexMock.use(Time) do |time_proxy|
	    current_time = Time.now + 5
	    time_proxy.should_receive(:now).and_return { current_time }

	    assert_equal(2, loop_planner.patterns.size)
	    first_planner  = loop_planner.patterns[-1].first
	    second_planner = loop_planner.patterns[-2].first
	    assert(first_planner.running?)
	    assert(!second_planner.running?)

	    # Call #loop_start! already, to make the loop start the first running
	    # task as soon as it is ready.
	    loop_planner.loop_start!

	    # Usual pattern: wait for the result of the first two planners, check
	    # that the first task actually runs
	    first_task  = planning_task_result(first_planner)
	    second_task = planning_task_result(second_planner)
	    third_planner = loop_planner.patterns[-3].first
	    assert(third_planner.running?)
	    assert(first_task.running?)
	    assert(second_task.pending?)

	    # Make the first task finish and make sure the system does not start it right away
	    first_task.success!
	    assert(first_task.success?)
	    assert(second_task.pending?)

	    current_time += 0.2
	    process_events
	    assert(second_task.pending?)

	    current_time += 0.8
	    process_events
	    assert(second_task.running?)

	    # Use the third task to check that the timeout can be overriden by
	    # calling loop_start! on the PlanningLoop task
	    third_task = planning_task_result(third_planner)

	    assert(second_task.running? && !third_task.running?)
	    second_task.success!
	    loop_planner.loop_start!
	    assert(!second_task.running? && third_task.running?)
	end
    end

    # Test periodic loop tasks with zero lookahead
    def test_periodic_zero_lookahead
	FlexMock.use(Time) do |time_proxy|
	    current_time = Time.now + 5
	    time_proxy.should_receive(:now).and_return { current_time }

	    main_task, loop_planner = prepare_plan :period => 0.5, :lookahead => 0
	    loop_planner.start!

	    # Zero lookahead: no children until we call #loop_start!
	    assert(main_task.children.empty?)

	    # Start a first pattern
	    loop_planner.loop_start!(:id => 1)
	    assert_equal(1, loop_planner.patterns.size)
	    first_planner = loop_planner.last_planning_task
	    first_task    = planning_task_result(first_planner)
	    assert_equal(1, first_task.arguments[:id])

	    # Check the normal behaviour: a new pattern is to be added only when
	    # the first pattern has finished AND the period has occured.
	    assert(first_task.running?)
	    assert_equal([first_task], main_task.children.to_a)
	    first_task.success!
	    assert_equal([first_task], main_task.children.to_a)
	    current_time += 0.6
	    process_events
            second_proxy_task = main_task.children.to_a.first
            assert(second_proxy_task != first_task)
	    assert_equal(1, main_task.children.to_a.size)
	    assert(second_planner = loop_planner.last_planning_task)
	    assert(second_planner.running?)
	    second_task = planning_task_result(second_planner)
	    assert(second_task.running?)
	    assert_equal([second_task], main_task.children.to_a)

	    # And queue one other. The second call to #loop_start! should be
	    # completely ignored because there is already one pending pattern.
	    loop_planner.loop_start!(:id => 3)
	    loop_planner.loop_start!(:id => 4)
	    assert_equal(2, main_task.children.to_a.size)
	    assert(main_task.children.to_a.include?(second_task))
	    third_planner = loop_planner.last_planning_task
	    third_task  = planning_task_result(third_planner)
	    assert_equal(3, third_task.arguments[:id])
            assert_equal([second_task, third_task].to_value_set, main_task.children.to_value_set)

	    # Check the dynamic behaviour
	    # - the 3rd task should start as soon as the 2nd has: the call to
	    #   #loop_start! should have done that for us.
	    assert(second_task.running?)
	    assert(third_task.pending?)
	    second_task.success!
	    assert(second_task.success?)
            process_events
            assert_equal([third_task], main_task.children.to_a)
	    assert(third_task.running?)
	    third_task.success!
	    assert(third_task.success?)
	end
    end

    def test_reinit_periodic
        Roby.app.abort_on_exception = false
        main_task, loop_planner = prepare_plan :period => 0.5, :lookahead => 3

	FlexMock.use(Time) do |time_proxy|
	    current_time = Time.now + 5
	    time_proxy.should_receive(:now).and_return { current_time }
            FlexMock.use do |mock|
                mock.should_receive(:started).twice
                task_model.on(:start) { |ev| mock.started }

                loop_planner.start!
                planners = loop_planner.patterns.reverse.map { |t, _| t }
                tasks    = planners.map { |p| planning_task_result(p) }
                assert_equal 3, tasks.size
                assert_equal tasks.to_value_set, main_task.children.to_value_set

                loop_planner.loop_start!
                assert(tasks[0].running?)
                # First task is started, one pattern should be planning for the
                # sake of the lookahead
                assert_equal 1, (main_task.children.to_value_set - tasks.to_value_set).size
                assert_equal 4, loop_planner.patterns.size

                current_planning_task = loop_planner.patterns.first.first
                original_patterns = loop_planner.patterns.dup

                # reinit should remove all children and recreate the structure
                # for three patterns
                loop_planner.reinit!
                process_events
                assert(!loop_planner.event(:reinit).happened?)
                assert(tasks[0].running?)
                process_events
                assert(!tasks[0].running?)
                # if we're lucky, the planning task is not finished yet and
                # therefore the loop planner should not have emitted :reinit yet
                # either
                if current_planning_task.running?
                    wait_for_planning_end current_planning_task
                    assert(loop_planner.reinit_event.last.time >= current_planning_task.stop_event.last.time)
                end
                # Wait for the planning task to finish if it is not yet finished
                assert_equal 3, (loop_planner.patterns - original_patterns).size
                assert_equal 3, loop_planner.patterns.size
                assert_equal 3, main_task.children.to_a.size
                assert_equal 3, (main_task.children.to_value_set - tasks.to_value_set).size

                new_planners = loop_planner.patterns.reverse.map { |t, _| t }
                new_tasks    = new_planners.map { |p| planning_task_result(p) }

                new_tasks.each do |t|
                    assert(!tasks.include?(t))
                end
                # ... but the first pattern should be GCed right now, and the next
                # pattern started
                process_events
                assert(new_tasks[0].running?)
            end
        end
    end

    #def test_planning_loop_reinit_zero_lookahead
    #    task_model = Tasks::Simple.new_submodel
    #    planner_model = Class.new(Planning::Planner) do 
    #        @@id = 0
    #        method(:task) do 
    #    	task_model.new(:id => (@@id += 1))
    #        end
    #    end

    #    plan.add_mission(main_task = Roby::Task.new)
    #    loop_planner = PlanningLoop.new :period => nil, :lookahead => 0, 
    #        :planner_model => planner_model, :planned_model => Roby::Task, 
    #        :method_name => :task, :method_options => {}	
    #    main_task.planned_by loop_planner


    #    FlexMock.use do |mock|
    #        mock.should_receive(:started).twice
    #        task_model.on(:start) { |ev| STDERR.puts "started pattern #{ev.task}"; mock.started }

    #        loop_planner.start!
    #        loop_planner.loop_start!
    #        first_task, first_planner = planning_loop_next(main_task)
    #        assert(first_task.running?)

    #        loop_planner.reinit
    #        loop_planner.loop_start!
    #        old_first = first_task
    #        first_task, first_planner   = planning_loop_next(main_task)
    #        assert_equal(2, first_task.arguments[:id])

    #        assert(old_first.running?)
    #        assert(first_task.pending?)

    #        process_events
    #        assert(old_first.finished?)
    #        assert(first_task.running?)
    #    end
    #end

    def test_make_loop
        planner_model = Class.new(Planning::Planner) do
            include Test::Unit::Assertions

            @result_task = nil
            attr_reader :result_task
            method(:task) {  @result_task = Roby::Test::Tasks::Simple.new(:id => arguments[:task_id])}
            method(:looping_tasks) do
        	t1 = make_loop(:period => 0, :child_argument => 2) do
        	    # arguments of 'my_looping_task' shall be forwarded
        	    raise unless arguments[:parent_argument] == 1
        	    raise unless arguments[:child_argument] == 2
        	    task(:task_id => 'first_loop')
        	end
        	t2 = make_loop do
        	    task(:task_id => 'second_loop')
        	end
        	# Make sure the two loops are different
        	assert(t1.method_options[:id] != t2.method_options[:id])
        	[t1, t2]
            end
        end

        planner = planner_model.new(plan)
        t1, t2 = planner.looping_tasks(:parent_argument => 1)
        assert(t1.fully_instanciated?, "#{t1} should be fully instanciated, but is missing the following arguments: #{(t1.arguments.keys - t1.class.arguments.to_a).map(&:to_s).join(", ")}")
        assert(t2.fully_instanciated?)
        plan.add_mission(t1)
        plan.add_mission(t2)

        t1.start!
        planned_task = planning_task_result(t1.last_planning_task)
        assert_equal('first_loop', planned_task.arguments[:id])

        t2.start!
        planned_task = planning_task_result(t2.last_planning_task)
        assert_equal('second_loop', planned_task.arguments[:id])

        t3 = planner.make_loop(:period => 0, :parent_argument => 1, :child_argument => 2) do
            task(:task_id => 'third_loop')
        end
        plan.add_mission(t3)
        t3.start!
        assert_equal('third_loop', planning_task_result(t3.last_planning_task).arguments[:id])
    end
end
