# frozen_string_literal: true

require "roby/droby/logfile"
require "roby/droby/logfile/index"

module Roby
    module DRoby
        module Logfile
            # A class that reads log files generated by {Writer}
            class Reader
                # The current log format version
                FORMAT_VERSION = 5

                attr_reader :event_io

                def initialize(event_io, index_path: nil)
                    @event_io = event_io
                    @index_path = index_path ||
                                  "#{event_io.path.gsub(/\.log$/, '')}.idx"
                    event_io.rewind
                    options_hash = read_header
                    self.class.process_options_hash(options_hash)
                end

                def read_header
                    Logfile.read_prologue(event_io)
                    if (chunk = Logfile.read_one_chunk(event_io))
                        ::Marshal.load(chunk)
                    else
                        raise InvalidFileError,
                              "expected the prologue to be followed by one chunk, " \
                              "but got nothing"
                    end
                end

                def dup
                    Reader.new(event_io.dup)
                end

                def tell
                    event_io.tell
                end

                def close
                    event_io.close
                end

                def eof?
                    event_io.eof?
                end

                def closed?
                    event_io.closed?
                end

                def seek(pos)
                    event_io.seek(pos)
                end

                def read_one_chunk
                    Logfile.read_one_chunk(event_io)
                end

                def decode_one_chunk(chunk)
                    Logfile.decode_one_chunk(chunk)
                end

                def load_one_cycle
                    return unless (chunk = read_one_chunk)

                    decode_one_chunk(chunk)
                end

                def self.process_options_hash(options_hash)
                    options_hash[:plugins]&.each do |plugin_name|
                        begin
                            Roby.app.using plugin_name
                        rescue Roby::Application::PluginsDisabled
                            Roby.warn "the log file mentions the #{plugin_name} plugin, " \
                                      "but plugins are currently disabled. " \
                                      "Some information might not be displayed"
                        rescue ArgumentError
                            Roby.warn "the log file mentions the #{plugin_name} plugin, " \
                                      "but it is not available on this system. " \
                                      "Some information might not be displayed"
                        end
                    end
                end

                # The standard Roby index path, inferred from the log file's own
                # path
                #
                # @return [String]
                attr_reader :index_path

                def rebuild_index(path = index_path)
                    Logfile.warn "rebuilding index file for #{event_io.path}"
                    File.open(path, "w") do |index_io|
                        File.open(event_io.path) do |file_io|
                            Index.rebuild(file_io, index_io)
                        end
                    end
                    @index = nil
                end

                # Returns the index object for this event log
                def index(path = index_path, rebuild: true)
                    if @index
                        return @index
                    elsif !File.file?(path)
                        unless rebuild
                            raise IndexMissing, "there's no file #{path}"
                        end

                        rebuild_index(path)
                    end

                    index =
                        begin Index.read(path)
                        rescue Exception => e
                            raise e, "while reading index file #{path}: #{e.message}", e.backtrace
                        end
                    if index.valid_for?(event_io.path)
                        @index = index
                    elsif !rebuild
                        raise IndexInvalid, "#{path} is not a valid index for #{self}"
                    else
                        rebuild_index(path)
                        @index = Index.read(path)
                    end
                end

                # Open a reader on the file indicated by path
                #
                # @param [String] path the path to the file
                # @param [String,nil] index_path the path to the file's index. If nil,
                #   the index path will be the file's path with the '.log' extension
                #   replaced by '.idx'
                #
                # @overload open(path, index_path: nil)
                #   @return [Reader]
                #
                # @overload open(path, index_path: nil) { |reader| ... }
                #   @yieldparam [Reader] reader
                #   @return the value returned by the block
                #
                #   Yield the reader, and automatically closes it on return of the block
                def self.open(path, index_path: nil)
                    io = File.open(path)
                    reader = new(File.open(path), index_path: index_path)
                    return reader unless block_given?

                    begin
                        yield(reader)
                    ensure
                        reader.close unless reader.closed?
                    end
                rescue ::Exception
                    io.close if io && !io.closed?
                    raise
                end
            end
        end
    end
end
